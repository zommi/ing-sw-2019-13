LOCK RIFLE
    macro0
        micro0
           M
           1 player
           pp: visible(attacker)
    macro1
        micro0
            M
            1 player
            pp: different(0,0), visible(attacker)

ELECTRO
    macro0
        micro0
            M
            no input
            pp: generateFromSquare(attacker)
    macro1
        micro0
          M
          no input
          pp: generateFromSquare(attacker)

MACHINE GUN
    macro0
        micro0
            M
            1 o 2 player
            pp: visible(attacker)
    macro1
        micro0
            M
            1 player
            pp: inList(0,0), different(2,0)
    macro2
        micro0
            O
            1 player
            pp: inList(0,0), different(1,0)
        micro1
            O
            1 player
            pp: visible(attacker), different(1,0)

TRACTOR BEAM
    macro0
        micro0
            M
            move_flag
            1 player, 1 square
            sp: visible(attacker),    //p sta per player
            pp: distanceSmaller(3, square,  0,0) //nel senso che guarda la lista dei quadrati dell’effetto 0,0
    macro1
        micro0
            M
            move flag
            1 player
            sp: generateFromSquare(attacker)
            pp: distanceSmaller(3,   attacker)

THOR
    macro0
        micro0
            M
            1 player
            pp: visible(attacker)
    macro1
        micro0
            M
            1 player
            pp: visible(0,0), different(attacker)
    macro2 C(1,0) //anche (0,0) ma essendo base dovrebbe essere obbligatorio
        micro0
            M
            1 player
            pp: visible(1,0), different(attacker), different(0,0)

PLASMA GUN
    macro0
        micro0
            L
            move flag
            1 square
            sp: distanceSmaller(3, attacker)
            pp: generate(attacker)
        micro1
            M
            1 player
            pp: visible(attacker)
    macro1
        micro0
            L
            move flag
            1 square
            sp: distanceSmaller(3, attacker)
            pp: generate(attacker)
        micro1
            M
            no input
            pp: generate(0,1)
    macro2
        micro0
            L
            move flag
            1 square
            sp: distanceSmaller(3, attacker)
            pp: generate(attacker)

WHISPER
    macro0
        micro0
            M
            1 player
            pp: visible(attacker), distanceGreater(1, attacker)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

VORTEX CANNON
    macro0
        micro0
            M
            move flag
            1 square, 1 player
            sp: visible(attacker), different(attacker)             //different potrebbe essere la stessa cosa di notInList
            pp: distanceSmaller(2,  0,0)
    macro1
        micro0
            M
            move flag
            1 o 2 player
            sp: generate(0,0)   //prende il quadrato scelto in 0,0
            pp: distanceSmaller(2,  0,0), differentFromPlayer(0,0)
FURNACE
    macro0
        micro0
            M
            1 room
            rp: visible(attacker), different(attacker)
            pp: generateFromRoom(0,0)
    macro1
        micro0
            M
            1 noMoveSquare
            nmsp: distanceEqual(1, attacker)
            pp: generateFromNoMoveSquare(1,0)          //potrebbe esserci un generateFromMoveSquare e un generateFromSquare per distinguere

HEATSEEKER
    macro0
        micro0
            M
            1 player
            pp: invisible(attacker)

HELLION
    macro0
        micro0
            M
            1 player
            pp: visible(attacker), distanceGreater(0,  attacker)
        micro1
            M
            no input
            pp: generateFromSquare(0,0)       //deve andare a prendere il quadrato del giocatore scelto in 0,0
    macro1
        micro0
            M
            1 player
            pp: visible(attacker), distanceGreater(0,  attacker)
        micro1
            M
            no input
            pp: generateFromSquare(1,0)       //deve andare a prendere il quadrato del giocatore scelto in 1,0

FLAMETHROWER
    macro0
        micro0
            O
            1 player
            pp: distanceEqual(1, attacker)
        micro1
            O
            1 player
            pp: distanceEqual(1, 0,0), aligned(attacker, 0,0), distanceEqual(2, attacker)
    macro1
        micro0
            O
            1 noMoveSquare
            nmsp: distanceEqual(1, attacker)
            pp: generateFromNoMoveSquare(1,0)
        micro1
            O
            1 noMoveSquare
            nmsp: distanceEqual(1, 1,0), aligned(attacker, 1,0), distanceEqual(2, attacker)
            pp: generateFromNoMoveSquare(1,1)

GRENADE LAUNCHER
    macro0
        micro0
            M
            1 player
            pp: visible(attacker)
        micro1
            L
            move flag
            1 square
            sp: distanceEqual(1,  0,0)
            pp: generateFromPlayer(0,0)
    macro1
        micro0
            M
            1 noMoveSquare
            nmsp: visible(attacker)
            pp: generateFromNoMoveSquare(1,0)
        micro1
            L
            move flag
            1 square
            sp: distanceEqual(1,  0,0)
            pp: generateFromPlayer(0,0)

ROCKET LAUNCHER
    macro0
        micro0
            L
            move flag
            1 square
            sp: distanceSmaller(3, attacker), distanceGreater(0, attacker)
            pp: generate(attacker)
    macro1
        micro0
            M
            1 player
            pp: visible(attacker), distanceGreater(0, attacker)
        micro1
            O
            move flag
            1 square
            sp: distanceEqual(1, 1,0)
            pp: generateFromPlayer(1,0)
    macro2
        micro0
            L
            move flag
            1 square
            sp: distanceSmaller(3, attacker), distanceGreater(0, attacker)
            pp: generate(attacker)
    macro3
        micro0
            M
            no input
            pp: generate(1,0)
        micro1
            M
            no input
            pp: generate(fromSquare(1,0), different(1,0))   //different riferito a player
--------------------------------------------------------------------------------------------

RAILGUN
    macro0
        micro0
            M
            input: 1 player
            pp: sameDirection(attacker)
    macro1
        micro0
            M
            1 player
            pp: sameDirection(attacker)
        //micro1
            M
            1 player
            pp: sameDirection(attacker, 1,0), differentFromPlayer(1,0)

CYBER BLADE
    macro0
        micro0
            L
            move flag
            1 square
            sp: distanceEqual(1, attacker)
            pp: generate(attacker)
        micro1
            M
            input: 1 player
            pp: distanceEqual(0, attacker)
    macro1
        micro0
            L
            move flag
            1 square
            sp: distanceEqual(1, attacker)
            pp: generate(attacker)
        micro1
            M
            input: 1 player
            pp: distanceEqual(0, attacker), differentFromPlayer(0,1)
    macro2
        micro0
            L
            move flag
            1 square
            sp: distanceEqual(1, attacker)
            pp: generate(attacker)

ZX2
    macro0
        micro0
            M
            1 player
            pp: visible(attacker)
    macro1
        micro0
            M
            1, 2 o 3 player
            pp: visible(attacker)

SHOTGUN
    macro0
        micro0
            M
            1 player
            pp: distanceEqual(0, attacker)
        micro1
            O
            move flag
            1 square
            sp: distanceEqual(1, attacker)
            pp: generate(0,0)
    macro1
        micro0
            M
            1 player
            pp: distanceEqual(1, attacker)

POWER GLOVE
    macro0
        micro0
            M
            1 player
            pp: distanceEqual(1, attacker)
        micro1
            M
            move flag
            sp: generate(getSquareFromPlayer(0,0))      //fa un po' cagare cosi
            pp: generate(attacker)
    macro1
        micro0
            M
            move flag
            1 square
            sp: distanceEqual(1, attacker)
            pp: generate(attacker)
        micro1
            O
            1 player
            pp: onSquare(1,0)
        micro2
            O
            move flag
            1 square
            sp: distanceEqual(1, 1,0), aligned(attacker,  1,0)
            pp: generate(attacker)
        micro3
            C (1,2)
            1 player
            pp: onSquare(1,2)


SHOCKWAVE
    macro0
        micro0
            M
            1, 2, 3 player
            pp: distanceEqual(1, attacker), differentSquares()
    macro1
        micro0
            M
            no input
            pp: generate(distanceEqual(1, attacker))

SLEDGEHAMMER
    macro0
        micro0
            M
            1 player
            pp: distanceEqual(0, attacker)
    macro1
        micro0
            M
            1 player
            pp: distanceEqual(0, attacker)
        micro1
            O
            move flag
            1 square
            sp: distanceSmaller(3, attacker)
            pp: generate(1,0)       //from player



NOTE:
    se presente il move flag, ho per forza uno e un solo square destinazione (se ne avessi di piu, dividerei in piu microeffetti

    specificare inList(0,0, player) o (0,0,square) a seconda della lista a cui ci si riferisce e overloadare in base a cio su cui viene applicata la policy:
        esempio: se un giocatore deve essere inList(0,0,square) vuol dire che la posizione del giocatore deve essere nella lista di square

    metodo getMicroeffect(int, int) serve? magari per passarlo anziche ad esempio 0,0

    si potrebbe mettere un flag sul macroeffetto che dice se il macro ha micro, per evitare un botto di overhead visto che molti macro hanno un solo micro

    due categorie (o tre) di policy: player_target, move_square_target e square_target

    nelle policy generate se ci si riferisce allo stesso effetto in cui ci si trova, si potrebbe omettere l'argomento
    anche nella visible se non si mette niente ci si riferisce all'attacker

    effetti attivati a seconda della mappa e non di una scelta del giocatore: FLAMETHROWER 1,1

    mettere flag per generate e poi fare policy per generare: scelta dovuta a GRENADE LAUNCHER

    flag per dire che per l'arma conta l'ordine (le policy vanno verificate in base a modifiche precedenti della stessa arma)   //GRENADE, ROCKET ECC
    potrei fare un booleano che mi chiede (sia per granate e razzi) se usare l'effetto prima o dopo e poi tenere con
    FORSE SI RIESCE A FARE TUTTO CON UN POLICY SWITCHER SUI MICROEFFETTI PORCODIOO



10/5
    al posto di M o O, flag L che dice che quell'effetto si può usare facoltativamente ma
        solo un numero limitato di volte, in base a un contatore
        LO METTIAMO ANCHE AL MACROEFFETTO? VEDI ROCKET LAUNCHER

    magari al posto di generate(attacker) quando si muove il proprio personaggio si puo mettere
        qualcosa di meglio, ma magari no

    dividere in microeffetti mossa e microeffetti danno?

    attenzione nelle armi infami a non far pagare la mossa di movimento che dovrebbe essere gratis

    dividere policy per square e move square  //ma room invece?

    controllare limiti inferiori distanze

11/5
    come gestire 1 o 2 player in input, posto che l'effetto è obbligatorio: mettere un minimo e un massimo?

    inList(effetto) ad esempio in machine gun si basa deve passare tutti gli elementi dell'effetto, non solo il primo

    simmetria nei controlli, come gestirla: vedi machine gun macro1 e macro2

    onSquare da sostituire con distanceEqual(0)

    controllare che lista macro e micro sia ordinata per prevenire cheat

    generate(attacker) può diventare la policy generate(specificPlayer(attacker))
      la stessa cosa per una sp può diventare specificSquare

    problema di attivare macro con un solo micro L (potrebbe essere un problema in input)

JSON
    numeri degli effetti (magari inserirli durante il parsing)

    se c'e move flag chiedo un quadrato in input, non ho bisogno di size o altri flag

    sistemare macro0 obbligatorio per le EXTRA?

    different va specificato per giocatori/quadrati

    tutti i micro O allora almeno 1 va attivato: flag apposta o calcolo ogni volta o quando parso?

12/5
    attenzione alle armi EXTRA che non hanno l'effetto base obbligatorio come primo, es: lanciarazzi

    problema lanciarazzi ultimo effetto: ci si potrebbe riferire alla posizione nuova del bersaglio anche se serve quella vecchia
      si potrebbe mettere un flag old di cui tiene conto la policy per la distanza, che leggera la posizione vecchia(salvata magari nel giocatore)

    sameDirection usa tutti gli elementi della lista del suo tipo di policy(Railgun)

    aligned sostituibile con sameDirection

    sistemare flag limited tra micro e macro

    riguardare armi con square generato e le policy associate(es powerglove)

    problema boh: controllare prima di aver generato potrebbe esserlo
